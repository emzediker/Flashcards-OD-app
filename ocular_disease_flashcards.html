<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ocular Disease — Flashcards</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:0;padding:20px;background:#fff;color:#111;}
  .wrap{max-width:980px;margin:auto;}
  h1{font-size:22px;margin:0 0 12px;}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  select,input[type=search],button{padding:9px 10px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .card{border:1px solid #ddd;border-radius:12px;padding:20px;min-height:180px;background:#fff;position:relative}
  .front{font-weight:600}
  .back{display:none;margin-top:12px}
  .ans{font-weight:700;font-size:1.06rem;margin:2px 0 6px}
  .exp{color:#555;font-size:0.96rem;line-height:1.35}
  .card img{max-width:100%;height:auto;border-radius:8px;margin-top:10px}
  .fav{position:absolute;top:10px;right:10px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;background:#fff;cursor:pointer}
  .fav[aria-pressed="true"]{color:#e09b00;border-color:#caa14a}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#555}
  .nav{display:flex;gap:8px;margin-top:10px}
  .nav button{flex:1;font-weight:600}
  .note{margin-top:8px;font-size:13px;color:#666}
</style>
</head>
<body>
<div class="wrap">
  <h1>Ocular Disease — Flashcards</h1>

  <div class="bar">
    <label>Deck:
      <select id="deck"></select>
    </label>
    <label>Show:
      <select id="show">
        <option value="all">All</option>
        <option value="fav">Favorites</option>
      </select>
    </label>
    <label>Search:
      <input id="q" type="search" placeholder="Find text...">
    </label>
  </div>

  <div class="card" id="card">
    <div class="front" id="front"></div>
    <div class="back" id="back"></div>
    <button id="fav" class="fav" aria-pressed="false" title="Favorite">★</button>
  </div>

  <div class="meta">
    <div id="counter">0 / 0</div>
    <div id="status"></div>
  </div>

  <div class="nav">
    <button id="prev">◀ Prev</button>
    <button id="reveal">Reveal Answer</button>
    <button id="next">Next ▶</button>
  </div>

  <div class="note">Tip: ←/→ to move, R to reveal/hide, S to star. Favorites save per device & per deck.</div>
</div>

<script>
/* ------------------------------------------------------------------ */
/* 1) DECKS – IDs & TXT files MUST match your Admin page              */
/* ------------------------------------------------------------------ */
const DECKS = [
  { id:'ocular_dz_cornea',           title:'Cornea',                       dataUrl:'data/ocular_dz_cornea.txt' },
  { id:'ocular_dz_crystalline_uvea', title:'Crystalline Lens & Uvea',     dataUrl:'data/ocular_dz_crystalline_uvea.txt' },
  { id:'ocular_dz_neurology',        title:'Neurology',                   dataUrl:'data/ocular_dz_neurology.txt' },
  { id:'ocular_dz_trauma',           title:'Ocular Trauma',               dataUrl:'data/ocular_dz_trauma.txt' },
  { id:'ocular_dz_adnexa',           title:'Adnexa',                      dataUrl:'data/ocular_dz_adnexa.txt' },
  { id:'ocular_dz_conj_sclera',      title:'Conjunctiva & Sclera',        dataUrl:'data/ocular_dz_conj_sclera.txt' },
  { id:'ocular_dz_onh_bv',           title:'Optic Nerve & Blood Vessels', dataUrl:'data/ocular_dz_onh_bv.txt' },
  { id:'ocular_dz_retina',           title:'Retina',                      dataUrl:'data/ocular_dz_retina.txt' },
];

/* ------------------------------------------------------------------ */
/* 2) OPTIONAL IMAGE MAP – /images/<deckId>_image_map.json            */
/* ------------------------------------------------------------------ */
let IMAGE_MAP = {};
async function fetchImageMap(deckId){
  try{
    const r = await fetch(`images/${deckId}_image_map.json`, {cache:'no-store'});
    if(r.ok) return await r.json();
  }catch(e){}
  return {};
}
const imgTag = (src) => src ? `<img src="${src}" alt="">` : '';

/* ------------------------------------------------------------------ */
/* 3) FAVORITES (per deck, per device)                                */
/* ------------------------------------------------------------------ */
const FAV_KEY = deckId => `fc_favs_student_v1::${deckId}`;
function loadFavs(deckId){
  try{ return new Set(JSON.parse(localStorage.getItem(FAV_KEY(deckId))||'[]')); }
  catch{ return new Set(); }
}
function saveFavs(deckId,set){
  localStorage.setItem(FAV_KEY(deckId), JSON.stringify([...set]));
}

/* ------------------------------------------------------------------ */
/* 4) TEXT PARSER – strict "X of Y" anchors, ONLY split on " - "      */
/* ------------------------------------------------------------------ */
function escapeHtml(s){
  return s
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;');
}
function cleanLine(s){
  return s
    ? s.replace(/\u00A0/g,' ').replace(/\u200B/g,'').trim()
    : '';
}
function splitAnsExpl(line){
  if(!line) return {a:'',e:''};
  const m = line.match(/^(.+?)\s-\s(.+)$/);  // ONLY space-hyphen-space
  if(m) return {a:m[1].trim(), e:m[2].trim()};
  return {a:line.trim(), e:''};
}
function parseTxt(txt, deckId){
  const lines = txt.replace(/\r/g,'').split(/\n/).map(cleanLine);
  const isAnchor = s => /^\d+\s+of\s+\d+$/i.test(s);
  const anchors = [];
  for(let i=0;i<lines.length;i++){
    if(isAnchor(lines[i])) anchors.push(i);
  }
  const out = [];
  for(let p=0;p<anchors.length;p++){
    const at = anchors[p];
    const next = (p+1<anchors.length ? anchors[p+1] : lines.length);

    // FRONT: last non-empty line above anchor
    let j = at-1;
    while(j>=0 && !lines[j]) j--;
    const front = escapeHtml(lines[j]||'');

    // BACK: first non-empty line after anchor
    let k = at+1;
    while(k<next && !lines[k]) k++;
    const se = splitAnsExpl(lines[k]||'');

    out.push({
      id: `${deckId}-${p+1}`,
      front,
      backAns: escapeHtml(se.a),
      backExp: escapeHtml(se.e)
    });
  }
  return out;
}

/* ------------------------------------------------------------------ */
/* 5) UI + LOGIC                                                      */
/* ------------------------------------------------------------------ */
const els = {
  deck:    document.getElementById('deck'),
  show:    document.getElementById('show'),
  q:       document.getElementById('q'),
  front:   document.getElementById('front'),
  back:    document.getElementById('back'),
  favBtn:  document.getElementById('fav'),
  counter: document.getElementById('counter'),
  status:  document.getElementById('status'),
  prev:    document.getElementById('prev'),
  next:    document.getElementById('next'),
  reveal:  document.getElementById('reveal')
};

let CURRENT = null;
let CARDS   = [];
let VIEW    = [];
let FAVS    = new Set();
let idx     = 0;
let showing = false;

function applyFilters(){
  const term   = (els.q.value||'').toLowerCase();
  const favOnly= els.show.value === 'fav';
  VIEW = CARDS.filter(c =>
    (!term || (c.front + c.backAns + c.backExp).toLowerCase().includes(term)) &&
    (!favOnly || FAVS.has(c.id))
  );
  if(idx >= VIEW.length) idx = Math.max(0, VIEW.length-1);
  showing = false;
  render();
}

function render(){
  if(!VIEW.length){
    els.front.innerHTML = '<em>No cards match.</em>';
    els.back.style.display = 'none';
    els.back.innerHTML = '';
    els.favBtn.setAttribute('aria-pressed','false');
    els.counter.textContent = '0 / 0';
    els.reveal.textContent  = 'Reveal Answer';
    els.status.textContent  = CURRENT ? CURRENT.title : '';
    return;
  }

  const c   = VIEW[idx];
  const map = IMAGE_MAP[c.id] || {};

  els.front.innerHTML =
    (c.front || '') +
    (map.front ? imgTag(map.front) : '');

  els.back.innerHTML  =
    (c.backAns ? `<div class="ans">${c.backAns}</div>` : '') +
    (c.backExp ? `<div class="exp">${c.backExp}</div>` : '') +
    (map.back ? imgTag(map.back) : '');

  els.back.style.display = showing ? 'block' : 'none';
  els.favBtn.setAttribute('aria-pressed', FAVS.has(c.id) ? 'true' : 'false');
  els.counter.textContent = (idx+1) + ' / ' + VIEW.length;
  els.reveal.textContent  = showing ? 'Hide Answer' : 'Reveal Answer';
  els.status.textContent  = CURRENT.title + (els.show.value==='fav' ? ' (Favorites)' : '');
}

/* Navigation + actions */
function nextCard(){ if(!VIEW.length) return; idx = (idx+1) % VIEW.length; showing=false; render(); }
function prevCard(){ if(!VIEW.length) return; idx = (idx-1+VIEW.length) % VIEW.length; showing=false; render(); }
function toggleReveal(){ showing = !showing; render(); }
function toggleFav(){
  if(!VIEW.length) return;
  const c = VIEW[idx];
  if(FAVS.has(c.id)) FAVS.delete(c.id); else FAVS.add(c.id);
  saveFavs(CURRENT.id, FAVS);
  render();
}

/* ------------------------------------------------------------------ */
/* 6) LOAD A DECK                                                     */
/* ------------------------------------------------------------------ */
async function loadDeckById(id){
  CURRENT = DECKS.find(d=>d.id===id);
  idx=0; showing=false;
  els.counter.textContent='Loading…';
  els.status.textContent=CURRENT.title;

  try{
    const res = await fetch(CURRENT.dataUrl, {cache:'no-store'});
    const txt = await res.text();
    CARDS = parseTxt(txt, CURRENT.id);
  }catch(e){
    console.warn('Error loading deck', id, e);
    CARDS=[];
  }

  FAVS      = loadFavs(CURRENT.id);
  IMAGE_MAP = await fetchImageMap(CURRENT.id);
  applyFilters();
}

/* ------------------------------------------------------------------ */
/* 7) INIT                                                            */
/* ------------------------------------------------------------------ */
(function init(){
  // Populate deck dropdown
  els.deck.innerHTML = '';
  DECKS.forEach(d=>{
    const o=document.createElement('option');
    o.value=d.id;
    o.textContent=d.title;
    els.deck.appendChild(o);
  });

  if(DECKS.length){
    els.deck.value = DECKS[0].id;
    loadDeckById(DECKS[0].id);
  }

  // Wire events
  els.deck.onchange   = ()=>loadDeckById(els.deck.value);
  els.show.onchange   = applyFilters;
  els.q.oninput       = applyFilters;
  els.prev.onclick    = prevCard;
  els.next.onclick    = nextCard;
  els.reveal.onclick  = toggleReveal;
  els.favBtn.onclick  = toggleFav;

  document.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(k==='arrowright')      nextCard();
    else if(k==='arrowleft')  prevCard();
    else if(k==='r')          toggleReveal();
    else if(k==='s')          toggleFav();
  });
})();
</script>
</body>
</html>

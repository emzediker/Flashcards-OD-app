<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Perceptual Function & Color Vision — Flashcards</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:0;padding:20px;background:#fff;color:#111}
  .wrap{max-width:980px;margin:auto}
  h1{font-size:22px;margin:0 0 12px}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  select,input[type=search],button{padding:9px 10px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .card{border:1px solid #ddd;border-radius:12px;padding:20px;min-height:180px;background:#fff;position:relative}
  .front{font-weight:600}
  .back{display:none;margin-top:12px}
  .ans{font-weight:700;font-size:1.06rem;margin:2px 0 6px}
  .exp{color:#555;font-size:0.96rem;line-height:1.35}
  .fav{position:absolute;top:10px;right:10px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;background:#fff;cursor:pointer}
  .fav[aria-pressed="true"]{color:#e09b00;border-color:#caa14a}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#555}
  .nav{display:flex;gap:8px;margin-top:10px}
  .nav button{flex:1;font-weight:600}
  .note{margin-top:8px;font-size:13px;color:#666}
</style>
</head>
<body>
<div class="wrap">
  <h1>Perceptual Function & Color Vision — Flashcards</h1>

  <div class="bar">
    <label>Deck:
      <select id="deck"></select>
    </label>
    <label>Show:
      <select id="show">
        <option value="all">All</option>
        <option value="fav">Favorites</option>
      </select>
    </label>
    <label>Search:
      <input id="q" type="search" placeholder="Find text...">
    </label>
  </div>

  <div class="card" id="card">
    <div class="front" id="front"></div>
    <div class="back" id="back"></div>
    <button id="fav" class="fav" aria-pressed="false" title="Favorite">★</button>
  </div>

  <div class="meta">
    <div id="counter">0 / 0</div>
    <div id="status"></div>
  </div>

  <div class="nav">
    <button id="prev">◀ Prev</button>
    <button id="reveal">Reveal Answer</button>
    <button id="next">Next ▶</button>
  </div>

  <div class="note">Tip: ←/→ to move, R to reveal/hide, S to star. Favorites save per device & per deck.</div>
</div>

<script>
/* 1) Deck list */
const DECKS = [
  { id:'color_vision_1', title:'Color Vision — Deck 1', dataUrl:'data/color_vision_1.txt', totalHint:null },
  { id:'color_vision_2', title:'Color Vision — Deck 2', dataUrl:'data/color_vision_2.txt', totalHint:null },
];

/* 2) Favorites (per deck) */
const FKEY = id => `fc_favs_student_v1::${id}`;
const loadFavs = id => { try{return new Set(JSON.parse(localStorage.getItem(FKEY(id))||'[]'));}catch{return new Set();} };
const saveFavs = (id,set) => localStorage.setItem(FKEY(id), JSON.stringify([...set]));

/* 3) Parser */
function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
function cleanLine(s){
  if(!s) return '';
  return s.replace(/\u00A0/g,' ')
          .replace(/\u200B/g,'')
          .replace(/\uFFFD/g,'')
          .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
          .replace(/\u2013|\u2014/g,'-')
          .replace(/[^\S\r\n]+/g,' ')
          .trim();
}
/* Smart split: short bold answer + normal explanation */
function splitAnsExpl(line){
  if(!line) return {a:'',e:''};
  line=line.replace(/\u00A0/g,' ').replace(/\u200B/g,'').replace(/\u2013|\u2014/g,'-').trim();
  let m=line.match(/^(.{3,90}?)([:;–—-])\s+(.{10,})$/);
  if(m && m[1].split(/\s+/).length<=14) return {a:m[1].trim(),e:m[3].trim()};
  const dot=line.indexOf('. ');
  if(dot>0 && dot<100){
    const head=line.slice(0,dot).trim(), rest=line.slice(dot+2).trim();
    if(head.split(/\s+/).length<=12) return {a:head,e:rest};
  }
  return {a:line,e:''};
}

function parseTxt(txt,totalHint){
  const lines = txt.replace(/\r/g,'').split(/\n/).map(cleanLine);
  const isAnchor = s => totalHint ? new RegExp(String.raw`^\d+\s+of\s+${totalHint}$`).test(s) : /^\d+\s+of\s+\d+$/.test(s);
  const anchors=[]; for(let i=0;i<lines.length;i++) if(isAnchor(lines[i])) anchors.push(i);

  const out=[];
  for(let p=0;p<anchors.length;p++){
    const at=anchors[p], next=(p+1<anchors.length?anchors[p+1]:lines.length);
    // front: nearest non-empty line above the anchor
    let j=at-1, tries=8, front='';
    while(j>=0 && tries>0 && !lines[j]){ j--; tries--; }
    if(j>=0 && lines[j]) front=escapeHtml(lines[j]);

    // back: first non-empty after anchor (skip stray dots)
    let k=at+1; while(k<next && (!lines[k] || lines[k]==='.')) k++;
    const se = splitAnsExpl(k<next?lines[k]:'');
    const backAns=escapeHtml(se.a), backExp=escapeHtml(se.e);

    out.push({ id:`${CURRENT_DECK.id}-${out.length+1}`, front, backAns, backExp });
  }
  return out;
}

/* 4) UI logic */
const els={deck:deck,show:show,q:q,front:front,back:back,favBtn:fav,counter:counter,status:status,prev:prev,next:next,reveal:reveal};
let CURRENT_DECK=null, CARDS=[], VIEW=[], FAVS=new Set(), idx=0, showing=false;

function applyFilters(){
  const term=(els.q.value||'').toLowerCase(), favOnly=els.show.value==='fav';
  VIEW = CARDS.filter(c => (!term || (c.front+c.backAns+c.backExp).toLowerCase().includes(term)) && (!favOnly || FAVS.has(c.id)));
  if(idx>=VIEW.length) idx=Math.max(0,VIEW.length-1);
  showing=false; render();
}
function render(){
  if(!VIEW.length){
    els.front.innerHTML='<em>No cards match.</em>'; els.back.style.display='none'; els.back.innerHTML='';
    els.favBtn.setAttribute('aria-pressed','false'); els.counter.textContent='0 / 0';
    els.reveal.textContent='Reveal Answer'; els.status.textContent=CURRENT_DECK?CURRENT_DECK.title:''; return;
  }
  const c=VIEW[idx];
  els.front.innerHTML = c.front||'';
  els.back.innerHTML  =
    (c.backAns?`<div class="ans">${c.backAns}</div>`:'') +
    (c.backExp?`<div class="exp">${c.backExp}</div>`:'');
  els.back.style.display=showing?'block':'none';
  els.favBtn.setAttribute('aria-pressed', FAVS.has(c.id)?'true':'false');
  els.counter.textContent=(idx+1)+' / '+VIEW.length;
  els.reveal.textContent=showing?'Hide Answer':'Reveal Answer';
  els.status.textContent=CURRENT_DECK.title + (els.show.value==='fav'?' (Favorites)':'');
}
function nextCard(){ if(!VIEW.length) return; idx=(idx+1)%VIEW.length; showing=false; render(); }
function prevCard(){ if(!VIEW.length) return; idx=(idx-1+VIEW.length)%VIEW.length; showing=false; render(); }
function toggleReveal(){ showing=!showing; render(); }
function toggleFav(){ if(!VIEW.length) return; const c=VIEW[idx]; FAVS.has(c.id)?FAVS.delete(c.id):FAVS.add(c.id); saveFavs(CURRENT_DECK.id,FAVS); render(); }

/* 5) Load deck */
async function loadDeckById(id){
  CURRENT_DECK = DECKS.find(d=>d.id===id);
  idx=0; showing=false; els.counter.textContent='Loading…'; els.status.textContent=CURRENT_DECK.title;
  try{
    const res=await fetch(CURRENT_DECK.dataUrl,{cache:'no-store'}); if(!res.ok) throw new Error('Missing deck: '+CURRENT_DECK.dataUrl);
    const txt=await res.text(); CARDS=parseTxt(txt,CURRENT_DECK.totalHint);
  }catch(e){ console.warn(e); CARDS=[]; }
  FAVS = loadFavs(CURRENT_DECK.id);
  applyFilters();
}

/* 6) Init */
(function(){
  els.deck.innerHTML=''; DECKS.forEach(d=>{ const o=document.createElement('option'); o.value=d.id; o.textContent=d.title; els.deck.appendChild(o); });
  if(DECKS.length){ els.deck.value=DECKS[0].id; loadDeckById(DECKS[0].id); }
  els.deck.onchange=()=>loadDeckById(els.deck.value);
  els.show.onchange=applyFilters; els.q.oninput=applyFilters;
  els.prev.onclick=prevCard; els.next.onclick=nextCard; els.reveal.onclick=toggleReveal; els.favBtn.onclick=toggleFav;
  document.addEventListener('keydown',e=>{const k=e.key.toLowerCase(); if(k==='arrowright')nextCard(); else if(k==='arrowleft')prevCard(); else if(k==='r')toggleReveal(); else if(k==='s')toggleFav();});
})();
</script>
</body>
</html>

<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Merge & Split — Oculomotor/Sensory (2 decks)</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:0;padding:18px;background:#fff;color:#111}
  .card{max-width:860px;margin:auto;border:1px solid #ddd;border-radius:12px;padding:18px}
  h1{font-size:20px;margin:0 0 12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:10px 0}
  input[type=file]{padding:9px 12px;border:1px solid #ccc;border-radius:8px}
  button{padding:10px 14px;border:1px solid #999;border-radius:8px;background:#0a7; color:#fff; font-weight:600; cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  .muted{color:#666;font-size:13px}
  .box{padding:10px;border:1px dashed #bbb;border-radius:8px;background:#fafafa}
  .ok{color:#0a7}
  .warn{color:#b46900}
</style>
</head>
<body>
<div class="card">
  <h1>Merge → Split (2 decks) — Oculomotor/Sensory</h1>
  <div class="row">
    <input id="files" type="file" multiple accept=".txt,text/plain">
    <button id="goBtn">Merge → Split</button>
  </div>
  <div class="muted">Tip: order doesn’t matter; the tool merges everything, finds anchors like <code>“12 of 315”</code>, renumbers to start at 1, then splits into two even decks.</div>

  <div id="result" class="box" style="margin-top:12px">
    <div id="status">Waiting for files…</div>
    <div class="row" style="margin-top:8px">
      <button id="dl1" disabled>Download Deck 1</button>
      <button id="dl2" disabled>Download Deck 2</button>
    </div>
    <div class="muted">On iPad: tap each button once to get both files.</div>
  </div>
</div>

<script>
const $ = sel => document.querySelector(sel);
const filesInput = $('#files');
const goBtn = $('#goBtn');
const statusEl = $('#status');
const dl1 = $('#dl1');
const dl2 = $('#dl2');

let deck1Blob = null, deck2Blob = null;

// Read a File object as text
function readAsText(file){
  return new Promise((resolve,reject)=>{
    const r=new FileReader();
    r.onload = () => resolve(String(r.result||''));
    r.onerror = reject;
    r.readAsText(file);
  });
}

// Normalize common weird characters
function cleanLine(s){
  return s
    .replace(/\u00A0/g,' ')
    .replace(/\u200B/g,'')
    .replace(/\uFFFD/g,'')
    .replace(/[“”]/g,'"')
    .replace(/[‘’]/g,"'")
    .replace(/\u2013|\u2014/g,'-')
    .replace(/[ \t]+$/,'');
}

// Return [anchorIndexList, totalCardsGuessed]
function findAnchors(lines){
  const anchors = [];
  const re = /^\s*(\d+)\s+of\s+(\d+)\s*$/i;
  for(let i=0;i<lines.length;i++){
    const m = lines[i].match(re);
    if(m) anchors.push({i, n:parseInt(m[1],10), total:parseInt(m[2],10)});
  }
  // best guess at total: max of seen 'total' or anchors length
  const totalGuess = anchors.length ? Math.max(...anchors.map(a=>a.total), anchors.length) : 0;
  return [anchors, totalGuess];
}

// Given merged text, renumber anchors to 1..N, preserving everything else
function renumberAnchors(text){
  const lines = text.replace(/\r/g,'').split('\n').map(cleanLine);
  const [anchors] = findAnchors(lines);

  if(!anchors.length) return { text: lines.join('\n'), count: 0 };

  // Collect card blocks based on anchors
  const blocks = [];
  for(let k=0;k<anchors.length;k++){
    const start = anchors[k].i;
    const end = (k+1<anchors.length) ? anchors[k+1].i : lines.length;
    const slice = lines.slice(start, end);
    blocks.push(slice);
  }

  // Renumber each block's first line to "X of N"
  const N = blocks.length;
  for(let x=0;x<blocks.length;x++){
    blocks[x][0] = `${x+1} of ${N}`;
  }

  const output = blocks.map(b=>b.join('\n')).join('\n');
  return { text: output, count: N };
}

// Split into two decks (nearly equal). Keeps complete cards by using anchors.
function splitIntoTwo(renumberedText){
  const lines = renumberedText.replace(/\r/g,'').split('\n');
  const [anchors, total] = findAnchors(lines);
  if(!anchors.length) return {a:renumberedText, b:''};

  const half = Math.ceil(total/2);
  const aStart = anchors[0].i;
  const aEnd   = (anchors[half] ? anchors[half].i : lines.length);

  const deckA = lines.slice(0, aEnd).join('\n');
  const deckB = lines.slice(aEnd).join('\n');

  // Renumber each half again so each starts at 1 of X
  const A = renumberAnchors(deckA).text;
  const B = renumberAnchors(deckB).text;

  return {a:A, b:B};
}

function makeDownload(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 2000);
}

goBtn.onclick = async () => {
  dl1.disabled = dl2.disabled = true; deck1Blob = deck2Blob = null;
  statusEl.innerHTML = 'Reading files…';

  const files = [...(filesInput.files||[])];
  if(!files.length){ statusEl.innerHTML = '<span class="warn">Please choose your TXT files first.</span>'; return; }

  // Read & merge
  try{
    const texts = await Promise.all(files.map(readAsText));
    const merged = texts.join('\n');

    // Clean + renumber
    statusEl.innerHTML = 'Renumbering anchors…';
    const { text: renumbered, count } = renumberAnchors(merged);
    if(!count){ statusEl.innerHTML = '<span class="warn">No anchors like “1 of 100” were found. Please check your files.</span>'; return; }

    // Split
    statusEl.innerHTML = `Found ${count} cards. Splitting into two decks…`;
    const {a, b} = splitIntoTwo(renumbered);

    deck1Blob = new Blob([a], {type:'text/plain'});
    deck2Blob = new Blob([b], {type:'text/plain'});

    dl1.disabled = !deck1Blob;
    dl2.disabled = !deck2Blob;

    statusEl.innerHTML = `<span class="ok">Ready.</span> Tap each button to download:
      <code>ocular_motor_sensory_1.txt</code> and <code>ocular_motor_sensory_2.txt</code>`;
  }catch(e){
    console.error(e);
    statusEl.innerHTML = '<span class="warn">Error reading files. Try again.</span>';
  }
};

dl1.onclick = () => { if(deck1Blob) makeDownload(deck1Blob, 'ocular_motor_sensory_1.txt'); };
dl2.onclick = () => { if(deck2Blob) makeDownload(deck2Blob, 'ocular_motor_sensory_2.txt'); };
</script>
</body>
</html>

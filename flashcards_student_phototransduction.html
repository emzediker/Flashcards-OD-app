<script>
const DECKS = [
  { id:'phototransduction', title:'Phototransduction Flashcards', dataUrl:'data/phototransduction.txt', totalHint:null }
];

async function fetchSharedImageMap(deckId){
  const url = `images/${deckId}_image_map.json`;
  try{ const r = await fetch(url,{cache:'no-store'}); if(r.ok) return await r.json(); }
  catch(e){}
  return {};
}
let IMAGE_MAP={};

const FAV_KEY = (deckId)=>`fc_favs_student_v1::${deckId}`;
function loadFavs(deckId){try{return new Set(JSON.parse(localStorage.getItem(FAV_KEY(deckId))||'[]'));}catch{return new Set();}}
function saveFavs(deckId,set){localStorage.setItem(FAV_KEY(deckId),JSON.stringify([...set]));}

function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
function cleanLine(s){if(!s)return'';return s.replace(/\u00A0/g,' ').replace(/\u200B/g,'').replace(/\uFFFD/g,'').replace(/[â€œâ€]/g,'"').replace(/[â€˜â€™]/g,"'").replace(/\u2013|\u2014/g,'-').replace(/[^\S\r\n]+/g,' ').trim();}

// Split ONLY on space-hyphen-space
function splitAnsExpl(line){
  if(!line) return {a:'', e:''};
  line=line.replace(/\u00A0/g,' ').replace(/\u200B/g,'').replace(/\u2013|\u2014/g,'-').replace(/[â€œâ€]/g,'"').replace(/[â€˜â€™]/g,"'").trim();
  const m=line.match(/^(.*?)\s-\s(.*)$/);
  if(m) return {a:m[1].trim(), e:m[2].trim()};
  return {a:line.trim(), e:''};
}

function parseTxt(txt,totalHint){
  const lines=txt.replace(/\r/g,'').split(/\n/).map(cleanLine);
  const isAnchor=(s)=> totalHint? new RegExp(String.raw`^\d+\s+of\s+${totalHint}$`).test(s): /^\d+\s+of\s+\d+$/.test(s);
  const anchors=[];for(let i=0;i<lines.length;i++) if(isAnchor(lines[i])) anchors.push(i);
  const out=[];
  for(let p=0;p<anchors.length;p++){
    const at=anchors[p], next=(p+1<anchors.length?anchors[p+1]:lines.length);
    let j=at-1, up=6, front='';while(j>=0&&up>0&&!lines[j]){j--;up--;}if(j>=0&&lines[j])front=escapeHtml(lines[j]);
    let k=at+1;while(k<next&&(!lines[k]||lines[k]==='.'))k++;
    const se=splitAnsExpl(k<next?lines[k]:'');
    let backAns=escapeHtml(se.a), backExp=escapeHtml(se.e);
    out.push({id:`${DECKS[0].id}-${out.length+1}`,front,backAns,backExp});
  }
  return out;
}

/* UI Logic */
const els={
  q: document.getElementById('q'),
  front: document.getElementById('front'),
  back: document.getElementById('back'),
  favBtn: document.getElementById('fav'),
  counter: document.getElementById('counter'),
  status: document.getElementById('status'),
  prev: document.getElementById('prev'),
  next: document.getElementById('next'),
  reveal: document.getElementById('reveal'),
  showSel: document.getElementById('show')
};

let CARDS=[],VIEW=[],FAVS=new Set(),idx=0,showing=false,currentDeckId=DECKS[0].id;

function render(){
  if(!VIEW.length){
    els.front.innerHTML='<em>No cards match.</em>';
    els.back.style.display='none';
    els.counter.textContent='0 / 0';
    els.favBtn.setAttribute('aria-pressed','false');
    return;
  }
  const c=VIEW[idx];
  const map=IMAGE_MAP[c.id]||{};
  els.front.innerHTML=(c.front||'')+(map.front?`<img src="${map.front}" alt="">`:'');
  els.back.innerHTML=(c.backAns?`<div class="ans">${c.backAns}</div>`:'')+
                     (c.backExp?`<div class="exp">${c.backExp}</div>`:'')+
                     (map.back?`<img src="${map.back}" alt="">`:'');
  els.back.style.display=showing?'block':'none';
  els.counter.textContent=(idx+1)+' / '+VIEW.length;
  els.reveal.textContent=showing?'Hide Answer':'Reveal Answer';

  // â­ update star state
  const isFav = FAVS.has(c.id);
  els.favBtn.setAttribute('aria-pressed', String(isFav));
}

function applyFilters(){
  const term=(els.q.value||'').toLowerCase();
  const showMode = els.showSel.value; // "all" or "fav"

  VIEW = CARDS.filter(c => {
    const matchesText = !term || (c.front + c.backAns + c.backExp).toLowerCase().includes(term);
    const matchesFav  = (showMode === 'fav') ? FAVS.has(c.id) : true;
    return matchesText && matchesFav;
  });

  if(idx>=VIEW.length) idx=Math.max(0,VIEW.length-1);
  showing=false;
  render();
}

async function loadDeck(){
  const deck=DECKS[0];
  currentDeckId = deck.id;
  els.counter.textContent='Loadingâ€¦';

  try{
    const res=await fetch(deck.dataUrl,{cache:'no-store'});
    const txt=await res.text();
    CARDS=parseTxt(txt,deck.totalHint);
  }catch(e){
    CARDS=[];
  }

  IMAGE_MAP=await fetchSharedImageMap(deck.id);
  FAVS=loadFavs(deck.id);    // ðŸ”¹ load saved favorites
  applyFilters();
}

/* Navigation */
function nextCard(){if(!VIEW.length)return;idx=(idx+1)%VIEW.length;showing=false;render();}
function prevCard(){if(!VIEW.length)return;idx=(idx-1+VIEW.length)%VIEW.length;showing=false;render();}
function toggleReveal(){showing=!showing;render();}

// â­ toggle favorite for current card
function toggleFavorite(){
  if(!VIEW.length) return;
  const c = VIEW[idx];
  if(FAVS.has(c.id)) FAVS.delete(c.id);
  else FAVS.add(c.id);
  saveFavs(currentDeckId, FAVS);
  render(); // refresh star state
}

(function(){
  loadDeck();

  els.q.oninput = applyFilters;
  els.showSel.onchange = applyFilters;       // ðŸ”¹ react to All/Favorites dropdown

  els.prev.onclick = prevCard;
  els.next.onclick = nextCard;
  els.reveal.onclick = toggleReveal;
  els.favBtn.onclick = toggleFavorite;       // ðŸ”¹ click star

  document.addEventListener('keydown',e=>{
    const k=e.key.toLowerCase();
    if(k==='arrowright') nextCard();
    else if(k==='arrowleft') prevCard();
    else if(k==='r') toggleReveal();
    else if(k==='s') toggleFavorite();       // ðŸ”¹ S to star/unstar
  });
})();
</script>

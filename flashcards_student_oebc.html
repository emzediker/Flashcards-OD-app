<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Part 2 Flashcards</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:0;padding:20px;background:#fff;color:#111;}
  .wrap{max-width:980px;margin:auto;}
  h1{font-size:22px;margin:0 0 12px;}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  select,input[type=search],button{padding:9px 10px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .card{border:1px solid #ddd;border-radius:12px;padding:20px;min-height:180px;background:#fff;position:relative}
  .front{font-weight:600}
  .back{display:none;margin-top:12px}

  /* back text */
  .back .exp{
    color:#111;
    font-size:0.98rem;
    line-height:1.5;
    white-space:normal;
  }

  .card img{max-width:100%;height:auto;border-radius:8px;margin-top:10px}
  .fav{position:absolute;top:10px;right:10px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;background:#fff;cursor:pointer}
  .fav[aria-pressed="true"]{color:#e09b00;border-color:#caa14a}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#555}
  .nav{display:flex;gap:8px;margin-top:10px}
  .nav button{flex:1;font-weight:600}
  .note{margin-top:8px;font-size:13px;color:#666}
  .email-row{margin-bottom:10px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
  .email-row input{min-width:230px;}
  .note-small{font-size:12px;color:#666;margin-left:6px;}

  /* section label styling */
  .sec{
    display:inline-block;
    font-weight:800;
  }
</style>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
<div class="wrap">
  <h1>Part 2 Flashcards</h1>

  <div class="email-row">
    <label>
      Email for cloud sync:
      <input id="emailInput" type="email" placeholder="name@example.com">
    </label>
    <button id="saveEmail">Save</button>
    <span id="emailStatus" class="note-small"></span>
  </div>

  <div class="bar">
    <label>Deck:
      <select id="deck"></select>
    </label>
    <label>Show:
      <select id="show">
        <option value="all">All</option>
        <option value="fav">Favorites</option>
      </select>
    </label>
    <label>Search:
      <input id="q" type="search" placeholder="Find text...">
    </label>
  </div>

  <div class="card" id="card">
    <div class="front" id="front"></div>
    <div class="back" id="back"></div>
    <button id="fav" class="fav" aria-pressed="false" title="Favorite">★</button>
  </div>

  <div class="meta">
    <div id="counter">0 / 0</div>
    <div id="status"></div>
  </div>

  <div class="nav">
    <button id="prev">◀ Prev</button>
    <button id="reveal">Reveal Answer</button>
    <button id="next">Next ▶</button>
  </div>

  <div class="note">
    Tip: ←/→ to move, R to reveal/hide, S to star.
    Favorites save per device and in the cloud when an email is set.
  </div>
  <div class="note" id="cloudStatus"></div>
</div>

<script>
/* ------------------------------------------------------------- */
/* Supabase config                                               */
/* ------------------------------------------------------------- */
const SUPABASE_URL = "https://ikcowmdwccncnhnuchos.supabase.co";
const SUPABASE_KEY = "YOUR_KEY_HERE"; // keep your existing key here

let supabaseClient = null;
try{
  if(window.supabase && window.supabase.createClient){
    supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
  }
}catch(e){
  console.error("Supabase init error:", e);
}

/* Email storage */
const EMAIL_STORAGE_KEY = "oebc_flashcards_user_email";
let USER_EMAIL = null;

/* ------------------------------------------------------------- */
/* 1) DECKS (OEBC decks only)                                    */
/* ------------------------------------------------------------- */
const DECKS = [
  { id:'oebc_retina_choroid_vitreous',       title:'Retina, Choroid, Vitreous',                dataUrl:'data/oebc_retina_choroid_vitreous.txt' },
  { id:'oebc_conjunctiva_cornea_refraction', title:'Conjunctiva, Cornea, Refractive Surgery',  dataUrl:'data/oebc_conjunctiva_cornea_refraction.txt' },
  { id:'oebc_optic_nerve_neuro',             title:'Optic Nerve & Neuro-Ophthalmology',        dataUrl:'data/oebc_optic_nerve_neuro.txt' },
  { id:'oebc_contact_lens',                  title:'Contact Lens',                             dataUrl:'data/oebc_contact_lens.txt' },
  { id:'oebc_crystalline_lens_cataracts',    title:'Crystalline Lens & Cataracts',             dataUrl:'data/oebc_crystalline_lens_cataracts.txt' },
  { id:'oebc_glaucoma',                      title:'Glaucoma',                                 dataUrl:'data/oebc_glaucoma.txt' },
  { id:'oebc_binocular_vision',              title:'Binocular Vision',                         dataUrl:'data/oebc_binocular_vision.txt' },
  { id:'oebc_lids_lashes_lacrimal',          title:'Lids, Lashes, Lacrimal System',            dataUrl:'data/oebc_lids_lashes_lacrimal.txt' },
  { id:'oebc_systemic_health',               title:'Systemic Health',                          dataUrl:'data/oebc_systemic_health.txt' },
  { id:'oebc_trauma',                        title:'Trauma',                                   dataUrl:'data/oebc_trauma.txt' },
  { id:'oebc_episclera_sclera_anterior_uveitis', title:'Episclera, Sclera, Anterior Uveitis', dataUrl:'data/oebc_episclera_sclera_anterior_uveitis.txt' },
  { id:'oebc_strabismus',                    title:'Strabismus',                               dataUrl:'data/oebc_strabismus.txt' },
  { id:'oebc_public_health',                 title:'Public Health',                            dataUrl:'data/oebc_public_health.txt' },
  { id:'oebc_ophthalmic_optics',             title:'Ophthalmic Optics',                        dataUrl:'data/oebc_ophthalmic_optics.txt' },
  { id:'oebc_perceptual_vision_color',       title:'Perceptual Vision & Color Vision',         dataUrl:'data/oebc_perceptual_vision_color.txt' },
  { id:'oebc_visual_human_development',      title:'Visual & Human Development',               dataUrl:'data/oebc_visual_human_development.txt' }
];

/* ------------------------------------------------------------- */
/* 2) Shared image map loader (optional)                          */
/* ------------------------------------------------------------- */
async function fetchSharedImageMap(deckId){
  try{
    const r = await fetch(`images/${deckId}_image_map.json`, {cache:'no-store'});
    if(r.ok) return await r.json();
  }catch(e){}
  return {};
}

/* ------------------------------------------------------------- */
/* 3) Favorites (local per deck)                                  */
/* ------------------------------------------------------------- */
const FAV_KEY = deckId => `fc_favs_student_v1::${deckId}`;
function loadFavs(deckId){
  try{ return new Set(JSON.parse(localStorage.getItem(FAV_KEY(deckId)) || "[]")); }
  catch{ return new Set(); }
}
function saveFavs(deckId,set){
  localStorage.setItem(FAV_KEY(deckId), JSON.stringify([...set]));
}

/* 3b) Cloud favorites via Supabase                               */
async function fetchCloudFavs(userEmail, deckId){
  if(!supabaseClient || !userEmail) return [];
  try{
    const { data, error } = await supabaseClient
      .from("flashcard_favorites")
      .select("card_id")
      .eq("user_email", userEmail)
      .eq("deck_id", deckId);
    if(error){ console.error("Error loading cloud favorites:", error); return []; }
    return (data||[]).map(row => row.card_id);
  }catch(e){
    console.error("Cloud favorites fetch error:", e);
    return [];
  }
}
async function addCloudFav(userEmail, deckId, cardId){
  if(!supabaseClient || !userEmail) return;
  try{
    const { error } = await supabaseClient
      .from("flashcard_favorites")
      .upsert({ user_email:userEmail, deck_id:deckId, card_id:cardId });
    if(error) console.error("Error adding cloud favorite:", error);
  }catch(e){ console.error("Cloud addFav error:", e); }
}
async function removeCloudFav(userEmail, deckId, cardId){
  if(!supabaseClient || !userEmail) return;
  try{
    const { error } = await supabaseClient
      .from("flashcard_favorites")
      .delete()
      .eq("user_email", userEmail)
      .eq("deck_id", deckId)
      .eq("card_id", cardId);
    if(error) console.error("Error removing cloud favorite:", error);
  }catch(e){ console.error("Cloud removeFav error:", e); }
}

/* ------------------------------------------------------------- */
/* 4) Parser (FIXED)                                              */
/*    Card boundary is next "X of Y" anchor, NOT blank lines.     */
/* ------------------------------------------------------------- */
function escapeHtml(s){
  return (s||"").replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
}
function normalizeLine(s){
  return (s||"").replace(/\u00A0/g,' ')
                .replace(/\u200B/g,'')
                .replace(/\uFFFD/g,'')
                .trim();
}
function isAnchor(s){ return /^\d+\s+of\s+\d+$/i.test(normalizeLine(s)); }

/* labels to bold */
const SECTION_LABELS = [
  "Definition","Epidemiology","Etiology","Pathophysiology","Symptoms","Signs","Clinical Signs",
  "Complications","Management","Treatment","Follow-up","Follow Up","Types","Risk Factors",
  "Classification","Diagnosis","Prognosis","Stages","Zones","Severity Scale","High Risk","CSME",
  "Follow-up Schedule","Follow Up Schedule","PPV Indications"
];

function formatSections(rawLines){
  // rawLines is an array of strings (may include blank lines)
  const out = rawLines.map(line=>{
    const t = normalizeLine(line);
    if(!t) return ""; // keep blank -> paragraph break later

    // Match "Label:" at start
    const m = t.match(/^([A-Za-z][A-Za-z\s\/\-()]{1,40})\s*:\s*(.*)$/);
    if(m){
      const label = m[1].trim();
      const rest  = m[2] || "";
      const isLabel = SECTION_LABELS.some(l => l.toLowerCase() === label.toLowerCase());
      if(isLabel){
        return `<span class="sec">${escapeHtml(label)}:</span> ${escapeHtml(rest)}`.trim();
      }
    }

    return escapeHtml(t);
  });

  // Convert blank runs into spacing
  // (blank line => extra break)
  let html = "";
  for(let i=0;i<out.length;i++){
    if(out[i]===""){
      // collapse multiple blanks into one paragraph gap
      if(!html.endsWith("<br><br>")) html += "<br><br>";
    }else{
      html += out[i] + "<br>";
    }
  }
  return html.replace(/(<br>)+$/,""); // trim trailing breaks
}

function parseTxt(txt, deckId){
  const raw = txt.replace(/\r/g,'').split("\n");
  const anchors = [];
  for(let i=0;i<raw.length;i++){
    if(isAnchor(raw[i])) anchors.push(i);
  }

  const out = [];
  for(let p=0;p<anchors.length;p++){
    const at = anchors[p];
    const nextAnchor = (p+1<anchors.length ? anchors[p+1] : raw.length);

    // Title is last non-empty line before anchor
    let j = at-1;
    while(j>=0 && !normalizeLine(raw[j])) j--;
    const title = normalizeLine(raw[j] || "");

    // Body is everything after anchor up to BEFORE the next title line (which sits above next anchor)
    // That title line is at (nextAnchor - 1)
    const bodyStart = at+1;
    const bodyEndExclusive = Math.max(bodyStart, nextAnchor - 1);

    const bodyRawLines = raw.slice(bodyStart, bodyEndExclusive);

    out.push({
      id: `${deckId}-${out.length+1}`,
      front: escapeHtml(title),
      backHtml: formatSections(bodyRawLines)
    });
  }
  return out;
}

/* ------------------------------------------------------------- */
/* 5) UI + logic                                                  */
/* ------------------------------------------------------------- */
const els = {
  deck:        document.getElementById('deck'),
  show:        document.getElementById('show'),
  q:           document.getElementById('q'),
  front:       document.getElementById('front'),
  back:        document.getElementById('back'),
  favBtn:      document.getElementById('fav'),
  counter:     document.getElementById('counter'),
  status:      document.getElementById('status'),
  prevBtn:     document.getElementById('prev'),
  nextBtn:     document.getElementById('next'),
  revealBtn:   document.getElementById('reveal'),
  emailInput:  document.getElementById('emailInput'),
  saveEmail:   document.getElementById('saveEmail'),
  emailStatus: document.getElementById('emailStatus'),
  cloudStatus: document.getElementById('cloudStatus')
};

let CURRENT_DECK = null;
let CARDS = [];
let VIEW = [];
let FAVS = new Set();
let IMAGE_MAP = {};
let idx = 0;
let showing = false;

function imgTag(src){ return src ? `<img src="${src}" alt="">` : ''; }

function setCloudStatus(msg){
  if(els.cloudStatus) els.cloudStatus.textContent = "Cloud: " + msg;
}
function updateEmailStatus(){
  if(!els.emailStatus) return;
  els.emailStatus.textContent = USER_EMAIL ? ("Using " + USER_EMAIL) : "No email set — cloud sync off (local only).";
}

function applyFilters(){
  const term = (els.q.value || '').toLowerCase();
  const favOnly = (els.show.value === 'fav');
  VIEW = CARDS.filter(c =>
    (!term || (c.front + c.backHtml).toLowerCase().includes(term)) &&
    (!favOnly || FAVS.has(c.id))
  );
  if(idx >= VIEW.length) idx = Math.max(0, VIEW.length-1);
  showing = false;
  render();
}

function render(){
  if(!VIEW.length){
    els.front.innerHTML = '<em>No cards match (or deck file not found).</em>';
    els.back.style.display='none';
    els.back.innerHTML='';
    els.favBtn.setAttribute('aria-pressed','false');
    els.counter.textContent='0 / 0';
    els.revealBtn.textContent='Reveal Answer';
    els.status.textContent = CURRENT_DECK ? CURRENT_DECK.title : '';
    return;
  }
  const c   = VIEW[idx];
  const map = IMAGE_MAP[c.id] || {};
  els.front.innerHTML = (c.front || '') + (map.front ? imgTag(map.front) : '');
  els.back.innerHTML  = `<div class="exp">${c.backHtml || ''}</div>` + (map.back ? imgTag(map.back) : '');
  els.back.style.display = showing ? 'block' : 'none';
  els.favBtn.setAttribute('aria-pressed', FAVS.has(c.id) ? 'true' : 'false');
  els.counter.textContent = (idx+1)+' / '+VIEW.length;
  els.revealBtn.textContent = showing ? 'Hide Answer' : 'Reveal Answer';
  els.status.textContent = CURRENT_DECK.title + (els.show.value==='fav' ? ' (Favorites)' : '');
}

function goNext(){ if(!VIEW.length) return; idx=(idx+1)%VIEW.length; showing=false; render(); }
function goPrev(){ if(!VIEW.length) return; idx=(idx-1+VIEW.length)%VIEW.length; showing=false; render(); }
function toggleReveal(){ showing=!showing; render(); }

async function toggleFav(){
  if(!VIEW.length) return;
  const c   = VIEW[idx];
  const cid = c.id;
  const isFav = FAVS.has(cid);

  if(isFav){
    FAVS.delete(cid);
    saveFavs(CURRENT_DECK.id, FAVS);
    render();
    if(USER_EMAIL) removeCloudFav(USER_EMAIL, CURRENT_DECK.id, cid);
  }else{
    FAVS.add(cid);
    saveFavs(CURRENT_DECK.id, FAVS);
    render();
    if(USER_EMAIL) addCloudFav(USER_EMAIL, CURRENT_DECK.id, cid);
  }
}

async function syncCloudFavsForCurrentDeck(){
  if(!supabaseClient){
    setCloudStatus("no Supabase client; using local-only favorites.");
    applyFilters();
    return;
  }
  if(!USER_EMAIL){
    setCloudStatus("no email set; using local-only favorites.");
    applyFilters();
    return;
  }
  const cloudFavs = await fetchCloudFavs(USER_EMAIL, CURRENT_DECK.id);
  for(const id of cloudFavs){
    if(!FAVS.has(id)) FAVS.add(id);
  }
  saveFavs(CURRENT_DECK.id, FAVS);
  setCloudStatus(`loaded ${cloudFavs.length} favorites from cloud for ${USER_EMAIL} on ${CURRENT_DECK.title}`);
  applyFilters();
}

async function loadDeckById(id){
  CURRENT_DECK = DECKS.find(d=>d.id===id);
  idx=0; showing=false;
  els.counter.textContent='Loading…';
  els.status.textContent = CURRENT_DECK.title;

  try{
    const res = await fetch(CURRENT_DECK.dataUrl, {cache:'no-store'});
    if(!res.ok) throw new Error('Deck file not found: '+CURRENT_DECK.dataUrl);
    const txt = await res.text();
    CARDS = parseTxt(txt, CURRENT_DECK.id);
  }catch(e){
    console.warn(e);
    CARDS = [];
  }

  FAVS = loadFavs(CURRENT_DECK.id);
  IMAGE_MAP = await fetchSharedImageMap(CURRENT_DECK.id);
  await syncCloudFavsForCurrentDeck();
}

(function init(){
  const stored = (localStorage.getItem(EMAIL_STORAGE_KEY) || '').trim();
  USER_EMAIL = stored || null;
  if(els.emailInput) els.emailInput.value = stored;
  updateEmailStatus();

  if(els.saveEmail){
    els.saveEmail.onclick = async () => {
      const v = (els.emailInput.value || '').trim();
      if(v){
        USER_EMAIL = v;
        localStorage.setItem(EMAIL_STORAGE_KEY, v);
      }else{
        USER_EMAIL = null;
        localStorage.removeItem(EMAIL_STORAGE_KEY);
      }
      updateEmailStatus();
      if(CURRENT_DECK){
        FAVS = loadFavs(CURRENT_DECK.id);
        await syncCloudFavsForCurrentDeck();
      }
    };
  }

  els.deck.innerHTML = '';
  DECKS.forEach(d=>{
    const o=document.createElement('option');
    o.value=d.id;
    o.textContent=d.title;
    els.deck.appendChild(o);
  });

  if(DECKS.length){
    els.deck.value = DECKS[0].id;
    loadDeckById(DECKS[0].id);
  }

  els.deck.onchange   = ()=>loadDeckById(els.deck.value);
  els.show.onchange   = applyFilters;
  els.q.oninput       = applyFilters;
  els.prevBtn.onclick = goPrev;
  els.nextBtn.onclick = goNext;
  els.revealBtn.onclick = toggleReveal;
  els.favBtn.onclick  = toggleFav;

  document.addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(k==='arrowright') goNext();
    else if(k==='arrowleft') goPrev();
    else if(k==='r') toggleReveal();
    else if(k==='s') toggleFav();
  });
})();
</script>
</body>
</html>

<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Systemic Anatomy, Physiology, & Disease Flashcards</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:0;padding:20px;background:#fff;color:#111;}
  .wrap{max-width:980px;margin:auto;}
  h1{font-size:22px;margin:0 0 12px;}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  select,input[type=search],button{padding:9px 10px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .card{border:1px solid #ddd;border-radius:12px;padding:20px;min-height:180px;background:#fff;position:relative}
  .front{font-weight:600}
  .back{display:none;margin-top:12px}
  .ans{font-weight:700;font-size:1.06rem;margin:2px 0 6px}
  .exp{color:#555;font-size:0.96rem;line-height:1.35}
  .card img{max-width:100%;height:auto;border-radius:8px;margin-top:10px}
  .fav{position:absolute;top:10px;right:10px;border:1px solid #ddd;border-radius:999px;padding:6px 10px;background:#fff;cursor:pointer}
  .fav[aria-pressed="true"]{color:#e09b00;border-color:#caa14a}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#555}
  .nav{display:flex;gap:8px;margin-top:10px}
  .nav button{flex:1;font-weight:600}
  .note{margin-top:8px;font-size:13px;color:#666}
</style>
</head>
<body>
<div class="wrap">
  <h1>Systemic Anatomy, Physiology, & Disease Flashcards</h1>

  <div class="bar">
    <label>Deck:
      <select id="deck"></select>
    </label>
    <label>Show:
      <select id="show">
        <option value="all">All</option>
        <option value="fav">Favorites</option>
      </select>
    </label>
    <label>Search:
      <input id="q" type="search" placeholder="Find text...">
    </label>
  </div>

  <div class="card" id="card">
    <div class="front" id="front"></div>
    <div class="back" id="back"></div>
    <button id="fav" class="fav" aria-pressed="false" title="Favorite">★</button>
  </div>

  <div class="meta">
    <div id="counter">0 / 0</div>
    <div id="status"></div>
  </div>

  <div class="nav">
    <button id="prev">◀ Prev</button>
    <button id="reveal">Reveal Answer</button>
    <button id="next">Next ▶</button>
  </div>

  <div class="note">Tip: ←/→ to move, R to reveal/hide, S to star. Favorites save per device & per deck.</div>
</div>

<script>
/* ------------------------------------------------------------------ */
/* 1) DECKS (multi-deck) — add the TXT files under /data/             */
/*    You already have systemic_basic.txt. Add others as you export.   */
/* ------------------------------------------------------------------ */
const DECKS = [
  { id:'systemic_basic', title:'Basic Body Organization & Chemistry', dataUrl:'data/systemic_basic.txt', totalHint:null, imageFolder:'images' },

  { id:'tissue_level',   title:'Cell & Tissue Level',                 dataUrl:'data/tissue_level.txt',   totalHint:null, imageFolder:'images' },
  { id:'skin_bone',      title:'Skin & Bone',                         dataUrl:'data/skin_bone.txt',      totalHint:null, imageFolder:'images' },
  { id:'muscular',       title:'The Muscular System',                 dataUrl:'data/muscular.txt',       totalHint:null, imageFolder:'images' },
  { id:'nervous',        title:'The Nervous System',                  dataUrl:'data/nervous.txt',        totalHint:null, imageFolder:'images' },
  { id:'special_senses', title:'Special Senses',                      dataUrl:'data/special_senses.txt', totalHint:null, imageFolder:'images' },
  { id:'blood_immune',   title:'Blood, Immune System & Stress',       dataUrl:'data/blood_immune.txt',   totalHint:null, imageFolder:'images' },
  { id:'cardiovascular', title:'The Cardiovascular System',           dataUrl:'data/cardiovascular.txt', totalHint:null, imageFolder:'images' },
  { id:'digestive',      title:'The Digestive System',                dataUrl:'data/digestive.txt',      totalHint:null, imageFolder:'images' },
  { id:'endocrine',      title:'The Endocrine System',                dataUrl:'data/endocrine.txt',      totalHint:null, imageFolder:'images' },
  { id:'reproduction',   title:'Reproduction, Development & Genetics',dataUrl:'data/reproduction.txt',   totalHint:null, imageFolder:'images' },
  { id:'respiratory',    title:'The Respiratory System',              dataUrl:'data/respiratory.txt',    totalHint:null, imageFolder:'images' },
  { id:'urinary_acid',   title:'The Urinary System & Acid-Base Balance', dataUrl:'data/urinary_acid.txt', totalHint:null, imageFolder:'images' },
];

/* ------------------------------------------------------------------ */
/* 2) IMAGE MAP — uses your saved pairings (systemic_basic populated). */
/*    Add similar entries for other decks later if you pair images.    */
/* ------------------------------------------------------------------ */
// Load image map saved by admin mode (localStorage)
const MAP_KEY_PREFIX = 'fc_imgmap_v1::';
function loadImageMap(deckId){
  try { return JSON.parse(localStorage.getItem(MAP_KEY_PREFIX + deckId) || '{}'); }
  catch { return {}; }
}
let IMAGE_MAP = {}; // set per deck on load

/* ------------------------------------------------------------------ */
/* 3) FAVORITES (per deck)                                            */
/* ------------------------------------------------------------------ */
const FAV_KEY = (deckId) => `fc_favs_student_v1::${deckId}`;
function loadFavs(deckId){ try{return new Set(JSON.parse(localStorage.getItem(FAV_KEY(deckId))||'[]'));}catch{return new Set();} }
function saveFavs(deckId, set){ localStorage.setItem(FAV_KEY(deckId), JSON.stringify([...set])); }

/* ------------------------------------------------------------------ */
/* 4) Sanitizer + Parser (robust; handles NBSP/odd chars)             */
/* ------------------------------------------------------------------ */
function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
function cleanLine(s){
  if(!s) return '';
  return s.replace(/\u00A0/g,' ')      // NBSP
          .replace(/\u200B/g,'')       // zero-width
          .replace(/\uFFFD/g,'')       // replacement char
          .replace(/[“”]/g,'"')
          .replace(/[‘’]/g,"'")
          .replace(/\u2013|\u2014/g,'-')
          .replace(/[^\S\r\n]+/g,' ')
          .trim();
}
function splitAnsExpl(line){
  let m=line.match(/^(.{1,80}?)[\s]*[:–—-]\s+(.{12,})$/); if(m) return {a:m[1].trim(),e:m[2].trim()};
  m=line.match(/^(.{1,60}?)[ ]{1,}([A-Z].{10,})$/); if(m && !/[.?!]$/.test(m[1])) return {a:m[1].trim(),e:m[2].trim()};
  const dot=line.indexOf('. '); if(dot>0 && dot<=80){ const first=line.slice(0,dot).trim(); const rest=line.slice(dot+2).trim(); if(first.split(/\s+/).length<=6) return {a:first,e:rest}; }
  return {a:line.trim(),e:''};
}
function parseTxt(txt, totalHint){
  const lines = txt.replace(/\r/g,'').split(/\n/).map(cleanLine);
  const isAnchor = (s)=> totalHint
    ? new RegExp(String.raw`^\d+\s+of\s+${totalHint}$`).test(s)
    : /^\d+\s+of\s+\d+$/.test(s);         // fallback: any “x of y”
  const anchors = []; for(let i=0;i<lines.length;i++) if(isAnchor(lines[i])) anchors.push(i);
  const out=[];
  for(let p=0;p<anchors.length;p++){
    const at=anchors[p], next=(p+1<anchors.length?anchors[p+1]:lines.length);
    let j=at-1, up=6, front=''; while(j>=0 && up>0 && !lines[j]){ j--; up--; } if(j>=0 && lines[j]) front = escapeHtml(lines[j]);
    let k=at+1; while(k<next && (!lines[k] || lines[k]==='.')) k++;
    const raw = (k<next?lines[k]:''); const se = splitAnsExpl(raw);
    let backAns=escapeHtml(se.a), backExp=escapeHtml(se.e);
    let m=k+1; while(m<next && !lines[m]) m++; if(m<next && /^(note|hint|comment)\s*:/i.test(lines[m])) backExp += (backExp?' ':'')+`<em>${escapeHtml(lines[m])}</em>`;
    out.push({ id:`${CURRENT_DECK.id}-${out.length+1}`, front, backAns, backExp });
  }
  return out;
}

/* ------------------------------------------------------------------ */
/* 5) UI + Logic                                                      */
/* ------------------------------------------------------------------ */
const els = {
  deck: document.getElementById('deck'),
  show: document.getElementById('show'),
  q:    document.getElementById('q'),
  front:document.getElementById('front'),
  back: document.getElementById('back'),
  favBtn:document.getElementById('fav'),
  counter:document.getElementById('counter'),
  status: document.getElementById('status'),
  prev: document.getElementById('prev'),
  next: document.getElementById('next'),
  reveal: document.getElementById('reveal')
};

let CURRENT_DECK = null;
let CARDS = [];
let VIEW = [];
let FAVS = new Set();
let idx = 0, showing = false;

function imgTag(src){ return src ? `<img src="${src}" alt="">` : ''; }
function applyFilters(){
  const q=(els.q.value||'').toLowerCase();
  const favOnly = els.show.value==='fav';
  VIEW = CARDS.filter(c =>
    (!q || (c.front + c.backAns + c.backExp).toLowerCase().includes(q)) &&
    (!favOnly || FAVS.has(c.id))
  );
  if(idx>=VIEW.length) idx = Math.max(0, VIEW.length-1);
  showing=false; render();
}
function render(){
  if(!VIEW.length){
    els.front.innerHTML = '<em>No cards match.</em>';
    els.back.style.display='none'; els.back.innerHTML='';
    els.favBtn.setAttribute('aria-pressed','false');
    els.counter.textContent='0 / 0';
    els.reveal.textContent='Reveal Answer';
    els.status.textContent = CURRENT_DECK ? CURRENT_DECK.title : '';
    return;
  }
  const c = VIEW[idx];
  const map = IMAGE_MAP[c.id] || {};
  els.front.innerHTML = (c.front||'');
  els.back.innerHTML  =
    (c.backAns?`<div class="ans">${c.backAns}</div>`:'') +
    (c.backExp?`<div class="exp">${c.backExp}</div>`:'') +
    (map.back?imgTag(map.back):'');
  els.back.style.display = showing?'block':'none';
  els.favBtn.setAttribute('aria-pressed', FAVS.has(c.id)?'true':'false');
  els.counter.textContent = (idx+1)+' / '+VIEW.length;
  els.reveal.textContent = showing?'Hide Answer':'Reveal Answer';
  els.status.textContent = CURRENT_DECK.title + (els.show.value==='fav' ? ' (Favorites)' : '');
}

/* nav + actions */
function next(){ if(!VIEW.length) return; idx=(idx+1)%VIEW.length; showing=false; render(); }
function prev(){ if(!VIEW.length) return; idx=(idx-1+VIEW.length)%VIEW.length; showing=false; render(); }
function toggle(){ showing=!showing; render(); }
function toggleFav(){ if(!VIEW.length) return; const c=VIEW[idx]; if(FAVS.has(c.id)) FAVS.delete(c.id); else FAVS.add(c.id); saveFavs(CURRENT_DECK.id, FAVS); render(); }

/* load a deck */
async function loadDeckById(id){
  CURRENT_DECK = DECKS.find(d=>d.id===id);
  idx=0; showing=false; els.counter.textContent='Loading…'; els.status.textContent=CURRENT_DECK.title;
  try{
    const res = await fetch(CURRENT_DECK.dataUrl, {cache:'no-store'});
    if(!res.ok) throw new Error('Deck file not found: '+CURRENT_DECK.dataUrl);
    const txt = await res.text();
    CARDS = parseTxt(txt, CURRENT_DECK.totalHint);
  }catch(e){
    console.warn(e);
    CARDS = [];
  }
  FAVS = loadFavs(CURRENT_DECK.id);
 IMAGE_MAP = loadImageMap(CURRENT_DECK.id);
  applyFilters();
}

/* populate deck dropdown */
(function init(){
  els.deck.innerHTML='';
  DECKS.forEach(d=>{ const o=document.createElement('option'); o.value=d.id; o.textContent=d.title; els.deck.appendChild(o); });
  // default to first deck
  if(DECKS.length){ els.deck.value = DECKS[0].id; loadDeckById(DECKS[0].id); }
  // events
  els.deck.onchange = ()=>loadDeckById(els.deck.value);
  els.show.onchange = applyFilters;
  els.q.oninput = applyFilters;
  els.prev.onclick = prev;
  els.next.onclick = next;
  els.reveal.onclick = toggle;
  els.favBtn.onclick = toggleFav;
  document.addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(k==='arrowright') next();
    else if(k==='arrowleft') prev();
    else if(k==='r') toggle();
    else if(k==='s') toggleFav();
  });
})();
</script>
</body>
</html>
